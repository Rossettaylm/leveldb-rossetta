// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.

#include "leveldb/filter_policy.h"
#include "leveldb/slice.h"
#include "util/hash.h"

namespace leveldb {

namespace {
static uint32_t BloomHash(const Slice& key) {
    return Hash(key.data(), key.size(), 0xbc9f1d34);
}

/**
 * @brief 布隆过滤器原则：bit位中所有的哈希函数都匹配上，则key可能存在于keys集合中；如果有一个没有匹配上，则将其过滤(一定不匹配)
 *
 */
class BloomFilterPolicy : public FilterPolicy {
  public:
    //* 根据bloom filter论文推断，当满足k = ln2 * (m/n)时，获得最优准确率
    //* 1. 哈希函数的个数k
    //* 2. 底层位数组的长度m
    //* 3. 数据集大小n
    //* 4. m/n为集合中每个key平均分到的bit数
    explicit BloomFilterPolicy(int bits_per_key) : bits_per_key_(bits_per_key) {
        // We intentionally round down to reduce probing cost a little bit
        //* 确定最优哈希函数的个数
        k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
        if (k_ < 1) {
            k_ = 1;
        } else if (k_ > 30) {
            k_ = 30;
        }
    }

    const char* Name() const override { return "leveldb.BuiltinBloomFilter2"; }

    void CreateFilter(const Slice* keys, int n,
                      std::string* dst) const override {
        //* step1. 计算bloom filter的bit数组长度，进行向上取整的操作，满足字节数
        // Compute bloom filter size (in both bits and bytes)
        size_t bits = n * bits_per_key_;
        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) bits = 64;

        size_t bytes = (bits + 7) / 8; // 向上取整
        bits = bytes * 8;

        //* step2. bloom filter需要bytes空间
        const size_t init_size = dst->size();
        dst->resize(init_size + bytes, 0);  // 对dst进行append
        dst->push_back(
            static_cast<char>(k_));  // 在dst的末尾记下哈希函数的个数 init + bits + char(k_)

        char* array = &(*dst)[init_size];       // 获取bloom filter的开始指针
        //* step3. 遍历传入的keys集合，进行哈希并赋值给dst
        for (int i = 0; i < n; i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            //? 未使用真正的k个哈希函数，而是使用double hashing的方法进行了优化，来接近达到相似的正确率，见[Kirsch,Mitzenmacher 2006]
            uint32_t h = BloomHash(keys[i]); // 得到初始哈希值
            const uint32_t delta =
                (h >> 17) | (h << 15);  // 循环右移17位作为步长

            // 执行k_次哈希迭代，每次的哈希值加上一个delta
            for (size_t j = 0; j < k_; j++) {
                const uint32_t bitpos = h % bits;
                array[bitpos / 8] |= (1 << (bitpos % 8));       // bitpos / 8为所在第几个字节，| = (1 << (bitpos % 8))为字节内的第几位置为1
                h += delta;
            }
        }
    }

    bool KeyMayMatch(const Slice& key,
                     const Slice& bloom_filter) const override {
        const size_t len = bloom_filter.size();
        if (len < 2) return false;

        const char* array = bloom_filter.data();
        const size_t bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len - 1];        // 最后一位记录哈希函数的个数k
        if (k > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            // 超过了我们初始设定的最大k个数，直接返回true，不过滤掉该sstable，进行下一级查找
            return true;
        }

        uint32_t h = BloomHash(key);
        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
        for (size_t j = 0; j < k; j++) {
            const uint32_t bitpos = h % bits;
            if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0) return false;       // 如果有一个哈希值不匹配直接返回false
            h += delta;
        }
        return true;
    }

  private:
    size_t bits_per_key_;
    size_t k_;
};
}  // namespace

const FilterPolicy* NewBloomFilterPolicy(int bits_per_key) {
    return new BloomFilterPolicy(bits_per_key);
}

}  // namespace leveldb
