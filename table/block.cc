// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include <algorithm>
#include <cstdint>
#include <vector>

#include "leveldb/comparator.h"
#include "table/block.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

inline uint32_t Block::NumRestarts() const {
    assert(size_ >= sizeof(uint32_t));
    return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
    if (size_ < sizeof(uint32_t)) {
        size_ = 0;  // Error marker
    } else {
        // 计算最大的restart point的个数
        size_t max_restarts_allowed =
            (size_ - sizeof(uint32_t)) / sizeof(uint32_t);

        if (NumRestarts() > max_restarts_allowed) {
            // The size is too small for NumRestarts()
            size_ = 0;
        } else {
            // num * restart point(uint32) + restart point len(uint32)
            // 计算restart point开始的offset
            restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
        }
    }
}

Block::~Block() {
    if (owned_) {
        delete[] data_;
    }
}

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns nullptr.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
/**
 * @brief 静态局部函数: 解码下个block entry，用于Iter接口
 *
 * @param p : const char * -- entry开始位置
 * @param limit : const char * -- 结束位置（外部调用时一般传入data的结尾部分，即restart point array开始位置）
 * @param shared : uint32_t * -- 存储key值共享部分长度
 * @param non_shared : uint32_t * -- 存储key值非共享部分长度
 * @param value_length : uint32_t * -- 存储value的长度
 * @return const char* 如果解码错误返回nullptr,否则返回unshared key content开始位置
 */
//? | shared key len | unshared key len | value len | unshared key content | value |
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared, uint32_t* non_shared,
                                      uint32_t* value_length) {
    if (limit - p < 3) return nullptr;

    //* step1. 先获取前三个字节做一个快速判断
    *shared = reinterpret_cast<const uint8_t*>(p)[0];
    *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
    *value_length = reinterpret_cast<const uint8_t*>(p)[2];

    if ((*shared | *non_shared | *value_length) < 128) {
        // Fast path: all three values are encoded in one byte each
        //* 快速判断：短键值情况下，三个长度值都仅用了一个字节的变长编码
        p += 3;  // 直接跳过长度部分
    } else {
        //* step2. 快速判断没通过，则连续获取3次变长编码长度值
        if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
        if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr)
            return nullptr;
        if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr)
            return nullptr;
    }

    if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
        return nullptr;
    }
    return p;
}

/**
 * @brief Block::Iter 通过restart point array进行快速定位，再遍历在区间内的entry
 *
 */
class Block::Iter : public Iterator {
  private:
    //? const部分，用于block划分
    const Comparator* const comparator_;
    const char* const data_;  // underlying block contents -- block data开始位置

    // 用于定位restart point array
    uint32_t const
        restarts_offset_;  // Offset of restart array (list of fixed32)
    uint32_t const
        num_restarts_;  // Number of uint32_t entries in restart array

    //? 非const部分，定位当前迭代器数据和restart point
    // current_ is offset in data_ of current entry.  >= restarts_offset_ if !Valid
    uint32_t current_;  // 指向当前entry的在data中的偏移(指向数据)
    uint32_t
        restart_index_;  // Index of restart block in which current_ falls -- 在current的情况下，重启点索引的位置(指向重启点)
    std::string key_;    // 存储当前entry的key值
    Slice value_;        // 存储当前entry的value值的slice
    Status status_;

    inline int Compare(const Slice& a, const Slice& b) const {
        return comparator_->Compare(a, b);
    }

    // Return the offset in data_ just past the end of the current entry.
    /**
     * @brief value是内存的slice视图，通过value进行下一个entry的定位
     *
     * @return uint32_t
     */
    inline uint32_t NextEntryOffset() const {
        return (value_.data() + value_.size()) - data_;
    }

    /**
     * @brief 获取第index个restart point的值
     *
     * @param index
     * @return uint32_t
     */
    uint32_t GetRestartPoint(uint32_t index) {
        assert(index < num_restarts_);
        return DecodeFixed32(data_ + restarts_offset_ +
                             index * sizeof(uint32_t));
    }

    /**
     * @brief 定位到第index个重启点，并清空相应的key和value
     *
     * @param index
     */
    void SeekToRestartPoint(uint32_t index) {
        key_.clear();
        restart_index_ = index;
        // current_ will be fixed by ParseNextKey();

        // ParseNextKey() starts at the end of value_, so set value_ accordingly
        //* ParseNextKey()接口需要从value的末尾开始，所以将value设置为restart point处的0字节切片
        //* 后续还需要通过ParseNextKey进行key，value以及current_的赋值
        uint32_t offset = GetRestartPoint(index);
        value_ = Slice(data_ + offset, 0);
    }

  public:
    Iter(const Comparator* comparator, const char* data,
         uint32_t restarts_offset, uint32_t num_restarts)
        : comparator_(comparator),
          data_(data),
          restarts_offset_(restarts_offset),
          num_restarts_(num_restarts),
          current_(restarts_offset_),  // 初始时指向data最末尾, 默认为!valid()
          restart_index_(num_restarts_)  // 设置为最大，指向最末尾restart point
    {
        assert(num_restarts_ > 0);
    }

    bool Valid() const override { return current_ < restarts_offset_; }
    Status status() const override { return status_; }
    Slice key() const override {
        assert(Valid());
        return key_;
    }
    Slice value() const override {
        assert(Valid());
        return value_;
    }

    void Next() override {
        assert(Valid());
        ParseNextKey();
    }

    void Prev() override {
        assert(Valid());

        // Scan backwards to a restart point before current_
        //* step1. 如果current位置大于等于重启点位置，首先先定位到上一个重启点
        const uint32_t original = current_;
        while (GetRestartPoint(restart_index_) >= original) {
            if (restart_index_ == 0) {
                // No more entries
                // 此时已经是第一个entry，prev是一个无效的iter
                current_ = restarts_offset_;
                restart_index_ = num_restarts_;
                return;
            }
            restart_index_--;
        }

        SeekToRestartPoint(restart_index_);

        //* step2. 向下寻找直到next entry >= original，即为所需要定位的prev entry
        do {
            // Loop until end of current entry hits the start of original entry
        } while (ParseNextKey() && NextEntryOffset() < original);
    }

    void Seek(const Slice& target) override {
        // Binary search in restart array to find the last restart point
        // with a key < target
        //* 二分搜索restart point array直到找到满足最后一个满足key < target的重启点
        uint32_t left = 0;
        uint32_t right = num_restarts_ - 1;
        // [left, right] 封闭区间进行查找

        int current_key_compare = 0;

        //* step1. 初步缩减区间，定位到restart_index作为开始点
        if (Valid()) {
            // If we're already scanning, use the current position as a starting
            // point. This is beneficial if the key we're seeking to is ahead of the
            // current position.
            //* 如果Iter已经不在初始位置（已经在扫描了），使用当前位置作为一个开始点；当我们寻找的target是当前位置的头部时，能加快seek的速度
            current_key_compare = Compare(key_, target);
            if (current_key_compare < 0) {
                // key_ is smaller than target
                left = restart_index_;  // key_小于target，向右查找
            } else if (current_key_compare > 0) {
                right = restart_index_;  // key_大于target，向左查找
            } else {
                // We're seeking to the key we're already at.
                // 当前key就是要寻找的target，直接返回
                return;
            }
        }

        //* step2. 二分查找直到left == right，定位到target所在的restart point index
        while (left < right) {
            uint32_t mid = (left + right + 1) / 2;
            uint32_t region_offset = GetRestartPoint(mid);
            uint32_t shared, non_shared, value_length;
            //* 解析mid的restart point所在的entry信息
            const char* key_ptr =
                DecodeEntry(data_ + region_offset, data_ + restarts_offset_,
                            &shared, &non_shared, &value_length);
            if (key_ptr == nullptr || (shared != 0)) {
                // shared != 0 时表明region_offset对应的位置非重启点，报错
                CorruptionError();
                return;
            }
            Slice mid_key(key_ptr, non_shared);

            //* 通过mid_key和target进行对比，寻找到比target更小的mid_key，从而找到对应的restart point，从而往下遍历查找target
            if (Compare(mid_key, target) < 0) {
                // Key at "mid" is smaller than "target".  Therefore all
                // blocks before "mid" are uninteresting.
                left = mid;  // mid_key < target，向右查找
            } else {
                // Key at "mid" is >= "target".  Therefore all blocks at or
                // after "mid" are uninteresting.
                right = mid - 1;  // target <= mid_key，向左查找
                // 当target == mid_key时，收缩右边界，以寻找target的左边界
            }
        }

        // We might be able to use our current position within the restart block.
        // This is true if we determined the key we desire is in the current block
        // and is after than the current key.
        assert(current_key_compare == 0 || Valid());
        bool skip_seek = left == restart_index_ && current_key_compare < 0;
        // 当且仅当left == right == restart_index_，且key < target时，target和key处于同一个restart point，不需要进行seek
        if (!skip_seek) {
            SeekToRestartPoint(left);
        }
        // Linear search (within restart block) for first key >= target
        while (true) {
            if (!ParseNextKey()) {
                return;  // 到达末尾，也返回，此时!valid()
            }
            // 直到找到一个大于等于target的key，则返回
            if (Compare(key_, target) >= 0) {
                return;
            }
        }
    }

    void SeekToFirst() override {
        SeekToRestartPoint(0);  // 定位到开始位置的restart point
        ParseNextKey();         // 解析第一个entry并更新到成员变量
    }

    void SeekToLast() override {
        SeekToRestartPoint(num_restarts_ - 1);  // 定位到最后一个restart point

        // 遍历entry到最后
        while (ParseNextKey() && NextEntryOffset() < restarts_offset_) {
            // Keep skipping
        }
    }

  private:
    void CorruptionError() {
        current_ = restarts_offset_;
        restart_index_ = num_restarts_;
        status_ = Status::Corruption("bad entry in block");
        key_.clear();
        value_.clear();
    }

    /**
     * @brief 解析下一个entry的数据并将其更新到成员变量中
     *
     * @return true
     * @return false
     */
    bool ParseNextKey() {
        //* step1. 移动到下个entry开始位置，并更新current_
        current_ = NextEntryOffset();

        //* step2. 获取p(entry开始地址)和limit(data结尾地址)
        const char* p = data_ + current_;
        const char* limit =
            data_ + restarts_offset_;  // Restarts come right after data
        if (p >= limit) {
            // No more entries to return.  Mark as invalid.
            current_ = restarts_offset_;
            restart_index_ = num_restarts_;
            return false;
        }

        // Decode next entry
        //* step2. 解码next entry同时将p定位到unshared key content开始部分
        uint32_t shared, non_shared, value_length;
        p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);

        if (p == nullptr || key_.size() < shared) {
            // 如果p == nullptr，说明Decode失败
            // 如果上个key值，即key_的大小小于shared部分则不能进行共享，表示编码有问题
            CorruptionError();
            return false;
        }

        //* step3. 编码有效，进行当前entry的key和value更新以及定位信息的更新
        key_.resize(shared);
        key_.append(p, non_shared);
        value_ = Slice(p + non_shared, value_length);

        // 更新到当前current entry对应的restart point index
        while (restart_index_ + 1 < num_restarts_ &&
               GetRestartPoint(restart_index_ + 1) < current_) {
            ++restart_index_;
        }
        return true;
    }
};

Iterator* Block::NewIterator(const Comparator* comparator) {
    if (size_ < sizeof(uint32_t)) {
        return NewErrorIterator(Status::Corruption("bad block contents"));
    }
    const uint32_t num_restarts = NumRestarts();
    if (num_restarts == 0) {
        return NewEmptyIterator();
    } else {
        return new Iter(comparator, data_, restart_offset_, num_restarts);
    }
}

}  // namespace leveldb
